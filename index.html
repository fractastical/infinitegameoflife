<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Dimensional Conway's Game of Life with Distinct Colors</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        #gameContainer {
            position: relative;
            width: 500px;
            height: 500px;
            margin-bottom: 20px;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            border: 1px solid #000;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            max-width: 500px;
        }
        button {
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
        }
        #info {
            text-align: center;
            margin-bottom: 20px;
        }
        #chartContainer {
            width: 500px;
            height: 400px;
            margin-top: 20px;
        }
        /* Right Sidebar Styles */
        #sidebar {
            position: fixed;
            right: -300px;
            top: 0;
            width: 300px;
            height: 100%;
            background-color: #333;
            color: white;
            padding: 20px;
            overflow-y: auto;
            transition: 0.3s ease;
            z-index: 9999;
        }

        #sidebar.open {
            right: 0;
        }

        #closeBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            cursor: pointer;
        }

        #openSidebarBtn {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            padding: 10px;
            background-color: #333;
            color: white;
            cursor: pointer;
            border-radius: 5px 0 0 5px;
            z-index: 9998;
        }

        #sidebar h3 {
            margin-top: 20px;
        }

        .patternCanvas {
            width: 100px;
            height: 100px;
            margin-bottom: 20px;
            border: 1px solid #fff;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="milestoneScores">
        <p>Score after 2 minutes: <span id="score2min">Not reached</span></p>
        <p>Score after 5 minutes: <span id="score5min">Not reached</span></p>
        <p>Score after 10 minutes: <span id="score10min">Not reached</span></p>
        <p>Score after 20 minutes: <span id="score20min">Not reached</span></p>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="500" height="500"></canvas>
    </div>
    
    <div id="controls">
        <button onclick="switchDimension()">Switch Dimension v 0.128</button>
        <button onclick="addDimension()">Add Dimension</button>
        <button onclick="addPattern('glider')">Add Glider</button>
        <button onclick="addPattern('blinker')">Add Blinker</button>
        <button onclick="addPattern('toad')">Add Toad</button>
        <button onclick="addPattern('beacon')">Add Beacon</button>
        <button onclick="addPattern('block')">Add Block</button>
        <button onclick="addPattern('beehive')">Add Beehive</button>
        <button onclick="addPattern('loaf')">Add Loaf</button>
        <button onclick="addPattern('boat')">Add Boat</button>
        <button onclick="addPattern('pulsar')">Add Pulsar</button>
        <button onclick="addPattern('glidergun')">Add Glider Gun</button>
        <button onclick="addPattern('r_pentomino')">Add R-pentomino</button>
        <button onclick="increasePropagation()">Increase Propagation Rate</button>
        <button onclick="increaseLifespan()">Increase Lifespan</button>
    </div>

    <div id="info">
        <p>Active Dimension: <span id="activeDimensionDisplay">1</span></p>
        <p>Total Dimensions: <span id="totalDimensionsDisplay">3</span></p>
        <p>Propagation Rate: <span id="propagationRateDisplay">100</span> ms</p>
        <p>Lifespan: <span id="lifespanDisplay">20</span> steps</p>
    </div>

    <div id="openSidebarBtn">Patterns</div>

    <div id="sidebar">
        <div id="closeBtn">X</div>
        <h2>Game of Life Patterns</h2>

        <!-- Render JavaScript Patterns -->
        <h3>Glider</h3>
        <p>The glider is a small, self-propagating pattern.</p>
        <canvas class="patternCanvas" id="gliderPattern"></canvas>

        <h3>Block</h3>
        <p>The block is a simple still life that remains stable over time.</p>
        <canvas class="patternCanvas" id="blockPattern"></canvas>

        <h3>Beehive</h3>
        <p>The beehive is another stable pattern that doesnâ€™t change over time.</p>
        <canvas class="patternCanvas" id="beehivePattern"></canvas>

        <h3>Loaf</h3>
        <p>The loaf is a still life that remains unchanged throughout the game.</p>
        <canvas class="patternCanvas" id="loafPattern"></canvas>

        <h3>Boat</h3>
        <p>The boat is a stable still life pattern.</p>
        <canvas class="patternCanvas" id="boatPattern"></canvas>

        <h3>Pulsar</h3>
        <p>The pulsar is a large, symmetric oscillator with a period of 3.</p>
        <canvas class="patternCanvas" id="pulsarPattern"></canvas>

        <h3>Glider Gun</h3>
        <p>The glider gun generates new gliders periodically.</p>
        <canvas class="patternCanvas" id="glidergunPattern"></canvas>

        <h3>R-pentomino</h3>
        <p>The R-pentomino is a methuselah pattern that evolves unpredictably.</p>
        <canvas class="patternCanvas" id="rpentominoPattern"></canvas>
    </div>

<script>
// Replace the empty IIFE with the full game implementation
(function() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const cellSize = 10;
    const cols = Math.floor(width / cellSize);
    const rows = Math.floor(height / cellSize);
    
    let score = 0;
    let gameStartTime = new Date();
    let twoMinuteScoreRecorded = false;
    let fiveMinuteScoreRecorded = false;
    let tenMinuteScoreRecorded = false;
    let twentyMinuteScoreRecorded = false;
    
    // Define game state
    let activeDimension = 1;
    let totalDimensions = 3;
    let propagationRate = 100; // milliseconds
    let lifespan = 20; // steps
    
    // Initialize multi-dimensional grid with unique color per dimension
    let dimensions = [];
    let dimensionColors = [];
    
    // Generate unique color for each dimension
    for (let d = 0; d < totalDimensions; d++) {
        dimensionColors[d] = getRandomColor();
        dimensions[d] = createEmptyGrid(dimensionColors[d]);
    }
    
    // Patterns
    const patterns = {
        glider: [[1, 0], [2, 1], [0, 2], [1, 2], [2, 2]],
        blinker: [[0, 1], [1, 1], [2, 1]],
        toad: [[1, 1], [2, 1], [3, 1], [0, 2], [1, 2], [2, 2]],
        beacon: [[0, 0], [1, 0], [0, 1], [3, 2], [2, 3], [3, 3]],
        block: [[0, 0], [0, 1], [1, 0], [1, 1]],
        beehive: [[1, 0], [2, 0], [0, 1], [3, 1], [1, 2], [2, 2]],
        loaf: [[1, 0], [2, 0], [0, 1], [3, 1], [1, 2], [3, 2], [2, 3]],
        boat: [[0, 0], [1, 0], [0, 1], [2, 1], [1, 2]],
        pulsar: [
            [2, 0], [3, 0], [4, 0], [8, 0], [9, 0], [10, 0],
            [0, 2], [5, 2], [7, 2], [12, 2],
            [0, 3], [5, 3], [7, 3], [12, 3],
            [0, 4], [5, 4], [7, 4], [12, 4],
            [2, 5], [3, 5], [4, 5], [8, 5], [9, 5], [10, 5],
            [2, 7], [3, 7], [4, 7], [8, 7], [9, 7], [10, 7],
            [0, 8], [5, 8], [7, 8], [12, 8],
            [0, 9], [5, 9], [7, 9], [12, 9],
            [0, 10], [5, 10], [7, 10], [12, 10],
            [2, 12], [3, 12], [4, 12], [8, 12], [9, 12], [10, 12]
        ],
        glidergun: [
            [24, 0], [22, 1], [24, 1], [12, 2], [13, 2], [20, 2], [21, 2], [34, 2], [35, 2],
            [11, 3], [15, 3], [20, 3], [21, 3], [34, 3], [35, 3], [0, 4], [1, 4], [10, 4], [16, 4],
            [20, 4], [21, 4], [0, 5], [1, 5], [10, 5], [14, 5], [16, 5], [17, 5], [22, 5], [24, 5],
            [10, 6], [16, 6], [24, 6], [11, 7], [15, 7], [12, 8], [13, 8]
        ],
        r_pentomino: [[1, 0], [2, 0], [0, 1], [1, 1], [1, 2]]
    };
    
    // Create empty grid with specified dimension color
    function createEmptyGrid(dimensionColor) {
        let arr = new Array(cols);
        for (let i = 0; i < cols; i++) {
            arr[i] = new Array(rows);
            for (let j = 0; j < rows; j++) {
                arr[i][j] = {
                    state: 0,
                    age: 0,
                    color: dimensionColor || getRandomColor() // Use dimension color if provided
                };
            }
        }
        return arr;
    }
    
    // Get random color
    function getRandomColor() {
        const r = Math.floor(Math.random() * 200) + 55;
        const g = Math.floor(Math.random() * 200) + 55;
        const b = Math.floor(Math.random() * 200) + 55;
        return `rgb(${r},${g},${b})`;
    }
    
    // Draw the current grid
    function draw() {
        ctx.clearRect(0, 0, width, height);
        
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                const cell = dimensions[activeDimension - 1][i][j];
                if (cell.state === 1) {
                    const alpha = Math.max(0.3, 1 - (cell.age / lifespan) * 0.7);
                    ctx.fillStyle = cell.color.replace('rgb', 'rgba').replace(')', `,${alpha})`);
                    ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }
        }
        
        // Draw grid lines
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 0.5;
        for (let i = 0; i <= cols; i++) {
            ctx.beginPath();
            ctx.moveTo(i * cellSize, 0);
            ctx.lineTo(i * cellSize, height);
            ctx.stroke();
        }
        for (let j = 0; j <= rows; j++) {
            ctx.beginPath();
            ctx.moveTo(0, j * cellSize);
            ctx.lineTo(width, j * cellSize);
            ctx.stroke();
        }
    }
    
    // Update the grid based on Conway's Game of Life rules
    function update() {
        for (let d = 0; d < totalDimensions; d++) {
            let nextGen = createEmptyGrid();
            
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const cell = dimensions[d][i][j];
                    const neighbors = countNeighbors(dimensions[d], i, j);
                    
                    // Cell keeps its color if it stays alive
                    nextGen[i][j].color = cell.color;
                    
                    if (cell.state === 1) {
                        // Rules for live cells
                        if (neighbors < 2 || neighbors > 3) {
                            nextGen[i][j].state = 0;
                            nextGen[i][j].age = 0;
                        } else {
                            nextGen[i][j].state = 1;
                            nextGen[i][j].age = cell.age + 1;
                            
                            // Cell dies of old age
                            if (nextGen[i][j].age > lifespan) {
                                nextGen[i][j].state = 0;
                                nextGen[i][j].age = 0;
                            }
                        }
                    } else {
                        // Rules for dead cells
                        if (neighbors === 3) {
                            nextGen[i][j].state = 1;
                            nextGen[i][j].age = 0;
                            // New cells have a chance to propagate to other dimensions
                            if (Math.random() < 0.05 && totalDimensions > 1) {
                                let targetDim = Math.floor(Math.random() * totalDimensions);
                                if (targetDim !== d) {
                                    dimensions[targetDim][i][j].state = 1;
                                    dimensions[targetDim][i][j].age = 0;
                                    dimensions[targetDim][i][j].color = dimensionColors[targetDim]; // Use target dimension's color
                                }
                            }
                            
                            // Increase score for new cells
                            score++;
                            document.getElementById('score').textContent = `Score: ${score}`;
                            
                            // Check for milestone scores
                            checkMilestoneScores();
                        }
                    }
                }
            }
            
            dimensions[d] = nextGen;
        }
    }
    
    // Count neighbors (including wrapping around edges)
    function countNeighbors(grid, x, y) {
        let sum = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                if (i === 0 && j === 0) continue;
                
                const col = (x + i + cols) % cols;
                const row = (y + j + rows) % rows;
                
                sum += grid[col][row].state;
            }
        }
        return sum;
    }
    
    // Game loop
    let gameInterval;
    function startGame() {
        gameInterval = setInterval(() => {
            update();
            draw();
        }, propagationRate);
    }
    
    // Check milestone scores
    function checkMilestoneScores() {
        const currentTime = new Date();
        const elapsedMinutes = (currentTime - gameStartTime) / 60000;
        
        if (elapsedMinutes >= 2 && !twoMinuteScoreRecorded) {
            document.getElementById('score2min').textContent = score;
            twoMinuteScoreRecorded = true;
        }
        
        if (elapsedMinutes >= 5 && !fiveMinuteScoreRecorded) {
            document.getElementById('score5min').textContent = score;
            fiveMinuteScoreRecorded = true;
        }
        
        if (elapsedMinutes >= 10 && !tenMinuteScoreRecorded) {
            document.getElementById('score10min').textContent = score;
            tenMinuteScoreRecorded = true;
        }
        
        if (elapsedMinutes >= 20 && !twentyMinuteScoreRecorded) {
            document.getElementById('score20min').textContent = score;
            twentyMinuteScoreRecorded = true;
        }
    }
    
    // Handle canvas click to toggle cells
    canvas.addEventListener('click', function(event) {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((event.clientX - rect.left) / cellSize);
        const y = Math.floor((event.clientY - rect.top) / cellSize);
        
        if (x >= 0 && x < cols && y >= 0 && y < rows) {
            const cell = dimensions[activeDimension - 1][x][y];
            cell.state = cell.state === 0 ? 1 : 0;
            cell.age = 0;
            if (cell.state === 1) {
                score++;
                document.getElementById('score').textContent = `Score: ${score}`;
            }
            draw();
        }
    });
    
    // Add pattern
    window.addPattern = function(patternName) {
        const pattern = patterns[patternName];
        if (!pattern) return;
        
        const centerX = Math.floor(cols / 2) - Math.floor(pattern.length / 2);
        const centerY = Math.floor(rows / 2) - Math.floor(pattern[0].length / 2);
        
        pattern.forEach(([dx, dy]) => {
            const x = centerX + dx;
            const y = centerY + dy;
            
            if (x >= 0 && x < cols && y >= 0 && y < rows) {
                dimensions[activeDimension - 1][x][y].state = 1;
                dimensions[activeDimension - 1][x][y].age = 0;
                score++;
            }
        });
        
        document.getElementById('score').textContent = `Score: ${score}`;
        draw();
    };
    
    // Switch dimension
    window.switchDimension = function() {
        activeDimension = (activeDimension % totalDimensions) + 1;
        document.getElementById('activeDimensionDisplay').textContent = activeDimension;
        draw();
    };
    
    // Add dimension
    window.addDimension = function() {
        if (totalDimensions < 10) {
            const newDimensionColor = getRandomColor();
            dimensionColors.push(newDimensionColor);
            dimensions.push(createEmptyGrid(newDimensionColor));
            totalDimensions++;
            document.getElementById('totalDimensionsDisplay').textContent = totalDimensions;
        }
    };
    
    // Increase propagation rate (decrease interval)
    window.increasePropagation = function() {
        if (propagationRate > 20) {
            propagationRate -= 10;
            document.getElementById('propagationRateDisplay').textContent = propagationRate;
            
            // Restart the game loop with the new interval
            clearInterval(gameInterval);
            startGame();
        }
    };
    
    // Increase lifespan
    window.increaseLifespan = function() {
        lifespan += 5;
        document.getElementById('lifespanDisplay').textContent = lifespan;
    };
    
    // Initialize the game
    draw();
    startGame();
})();
</script>

</body>
</html>
